{%- if block.settings.visibility != 'hide' -%}
  {%- liquid
    assign wrap_class = ''
    assign visibility = block.settings.visibility
    assign style = block.settings.style
  -%}
  {%- if style == 'minimalist' -%}
    {%- liquid
      assign wrap_class = ' flex'
      case visibility
        when 'desktop'
          assign wrap_class = ' hidden md:flex'
        when 'mobile'
          assign wrap_class = ' flex md:hidden'
      endcase
    -%}
    <link rel="stylesheet" href="{{ 'section-sticky-atc-bar-minimalist.css' | asset_url }}">
    <script src="{{ 'sticky-atc-bar-minimalist.js' | asset_url }}" defer="defer"></script>
    <sticky-atc-bar-minimalist
      class="sticky-atc-bar blocks-radius items-center justify-between gap-2{{ wrap_class }}"
      data-product-id="{{ product.id }}"
      data-section="{{ section.id }}">
      <div class="sticky-atc-bar__product flex items-center gap-3 md:gap-4">
        <div class="sticky-atc-bar__product-image media-wrapper shrink-0 blocks-radius-md{% if section.settings.show_image_border %} border-thin{% endif %}" style="--aspect-ratio: 1">
          {%- if product.featured_image -%}
            {{
              product.featured_media | image_url: width: 180 | image_tag: loading: 'lazy', fetchpriority: 'low', class: 'motion-reduce', widths: '70, 140', sizes: '70px', is: 'image-lazy'
            }}
          {%- else -%}
            {{ 'product-1' | placeholder_svg_tag: 'placeholder-svg' }}
          {%- endif -%}
        </div>
        <div class="sticky-atc-bar__product-info flex flex-col gap-0d5">
          <h3 class="sticky-atc-bar__product-title text-pcard-title text-limit-2-lines">
            {{ product.title }}
          </h3>
          {%- liquid
            assign isBundle = product.variants.first.metafields.custom.is_bundle
            assign bundleProducts = product.variants.first.metafields.custom.bundle_products.value
            assign bundleDiscount = product.variants.first.metafields.custom.bundle_discount.value
            assign bundleQuantities = product.variants.first.metafields.custom.bundle_quantities.value
            assign totalOriginalPrice = 0
            assign totalDiscountedPrice = 0

            if isBundle == true and bundleProducts != blank
              for component in bundleProducts
                assign componentQuantity = 1
                if bundleQuantities and bundleQuantities[forloop.index0]
                  assign componentQuantity = bundleQuantities[forloop.index0]
                endif
                assign componentPrice = component.price | times: componentQuantity
                assign totalOriginalPrice = totalOriginalPrice | plus: componentPrice
              endfor
              if bundleDiscount and bundleDiscount > 0
                assign discountAmount = totalOriginalPrice | times: bundleDiscount | divided_by: 100
                assign totalDiscountedPrice = totalOriginalPrice | minus: discountAmount
              else
                assign totalDiscountedPrice = totalOriginalPrice
              endif
            endif
          -%}

          {%- if isBundle == true and totalOriginalPrice > 0 -%}
            <div class="bundle-price-display">
              {%- if bundleDiscount and bundleDiscount > 0 -%}
                <div class="bundle-price-container" style="display: flex; flex-direction: column; gap: 0.25rem;">
                  <div class="bundle-price-main" style="display: flex; align-items: center; gap: 0.5rem;">
                    <span class="bundle-discounted-price" style="color: #dc2626; font-weight: 600; font-size: 0.875rem;">
                      {%- if settings.currency_code_enabled -%}
                        {{ totalDiscountedPrice | money_with_currency }}
                      {%- else -%}
                        {{ totalDiscountedPrice | money }}
                      {%- endif -%}
                    </span>
                    <span class="bundle-original-price" style="text-decoration: line-through; color: #6b7280; font-size: 0.75rem;">
                      {%- if settings.currency_code_enabled -%}
                        {{ totalOriginalPrice | money_with_currency }}
                      {%- else -%}
                        {{ totalOriginalPrice | money }}
                      {%- endif -%}
                    </span>
                  </div>
                  <div class="bundle-savings" style="color: #059669; font-weight: 500; font-size: 0.75rem;">
                    Save {{ bundleDiscount }}% ({{ discountAmount | money }})
                  </div>
                </div>
              {%- else -%}
                <div class="bundle-price-single" style="font-weight: 600; font-size: 0.875rem;">
                  {%- if settings.currency_code_enabled -%}
                    {{ totalOriginalPrice | money_with_currency }}
                  {%- else -%}
                    {{ totalOriginalPrice | money }}
                  {%- endif -%}
                </div>
              {%- endif -%}
            </div>
          {%- else -%}
            {%- render 'price'
              , product: product
              , use_variant: true -%}
          {%- endif -%}
        </div>
      </div>
      <div class="product-form__buttons flex items-center">
        <button
          type="submit"
          name="add"
          form="{{ product_form_id }}"
          class="product-form__submit btn btn--primary btn--small w-full"
          {% if product.selected_or_first_available_variant.available == false %}
          disabled
          {% endif %}>
          <span class="btn__text">
            {{ 'products.product.add_to_cart_short' | t }}
          </span>
          {% render 'loading-spinner' %}
        </button>
      </div>
    </sticky-atc-bar-minimalist>
  {%- else -%}
    {%- liquid
      assign show_dynamic_checkout_buttons = block.settings.show_dynamic_checkout_buttons
      case visibility
        when 'desktop'
          assign wrap_class = ' hidden md:block'
        when 'mobile'
          assign wrap_class = ' block md:hidden'
      endcase
    -%}
    <link rel="stylesheet" href="{{ 'section-sticky-atc-bar.css' | asset_url }}">
    <script src="{{ 'sticky-atc-bar.js' | asset_url }}" defer="defer"></script>
    <div class="sticky-atc-bar{{ wrap_class }}{% if show_dynamic_checkout_buttons %} sticky-atc-bar--with-dynamic-buttons{% endif %} page-width page-width--{{ block.settings.container }}">
      <sticky-atc-bar
        class="sticky-atc-bar__inner flex items-center justify-center lg:justify-between"
        data-product-id="{{ product.id }}"
        data-section="{{ section.id }}">
        <div class="sticky-atc-bar__product hidden lg:flex items-center gap-4">
          <div class="sticky-atc-bar__product-image media-wrapper blocks-radius-md{% if section.settings.show_image_border %} border-thin{% endif %}" style="--aspect-ratio: 1">
            {%- if product.featured_image -%}
              {{
                product.featured_media | image_url: width: 180 | image_tag: loading: 'lazy', fetchpriority: 'low', class: 'motion-reduce', widths: '70, 140', sizes: '70px', is: 'image-lazy'
              }}
            {%- else -%}
              {{ 'product-1' | placeholder_svg_tag: 'placeholder-svg' }}
            {%- endif -%}
          </div>
          <div class="sticky-atc-bar__product-info flex flex-col gap-1">
            <h3 class="sticky-atc-bar__product-title text-pcard-title text-limit-2-lines">
              {{ product.title }}
            </h3>
            {%- liquid
              assign isBundle = product.variants.first.metafields.custom.is_bundle
              assign bundleProducts = product.variants.first.metafields.custom.bundle_products.value
              assign bundleDiscount = product.variants.first.metafields.custom.bundle_discount.value
              assign bundleQuantities = product.variants.first.metafields.custom.bundle_quantities.value
              assign totalOriginalPrice = 0
              assign totalDiscountedPrice = 0

              if isBundle == true and bundleProducts != blank
                for component in bundleProducts
                  assign componentQuantity = 1
                  if bundleQuantities and bundleQuantities[forloop.index0]
                    assign componentQuantity = bundleQuantities[forloop.index0]
                  endif
                  assign componentPrice = component.price | times: componentQuantity
                  assign totalOriginalPrice = totalOriginalPrice | plus: componentPrice
                endfor
                if bundleDiscount and bundleDiscount > 0
                  assign discountAmount = totalOriginalPrice | times: bundleDiscount | divided_by: 100
                  assign totalDiscountedPrice = totalOriginalPrice | minus: discountAmount
                else
                  assign totalDiscountedPrice = totalOriginalPrice
                endif
              endif
            -%}

            {%- if isBundle == true and totalOriginalPrice > 0 -%}
              <div class="bundle-price-display">
                {%- if bundleDiscount and bundleDiscount > 0 -%}
                  <div class="bundle-price-container" style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <div class="bundle-price-main" style="display: flex; align-items: center; gap: 0.5rem;">
                      <span class="bundle-discounted-price" style="color: #dc2626; font-weight: 600; font-size: 0.875rem;">
                        {%- if settings.currency_code_enabled -%}
                          {{ totalDiscountedPrice | money_with_currency }}
                        {%- else -%}
                          {{ totalDiscountedPrice | money }}
                        {%- endif -%}
                      </span>
                      <span class="bundle-original-price" style="text-decoration: line-through; color: #6b7280; font-size: 0.75rem;">
                        {%- if settings.currency_code_enabled -%}
                          {{ totalOriginalPrice | money_with_currency }}
                        {%- else -%}
                          {{ totalOriginalPrice | money }}
                        {%- endif -%}
                      </span>
                    </div>
                    <div class="bundle-savings" style="color: #059669; font-weight: 500; font-size: 0.75rem;">
                      Save {{ bundleDiscount }}% ({{ discountAmount | money }})
                    </div>
                  </div>
                {%- else -%}
                  <div class="bundle-price-single" style="font-weight: 600; font-size: 0.875rem;">
                    {%- if settings.currency_code_enabled -%}
                      {{ totalOriginalPrice | money_with_currency }}
                    {%- else -%}
                      {{ totalOriginalPrice | money }}
                    {%- endif -%}
                  </div>
                {%- endif -%}
              </div>
            {%- else -%}
              {%- render 'price'
                , product: product
                , use_variant: true -%}
            {%- endif -%}
          </div>
        </div>
        {%- assign product_form_id = 'product-form-' | append: block.id -%}
        {%- form 'product'
          , product
          , id: product_form_id
          , class: 'sticky-atc-bar__form flex items-center justify-center md:justify-start gap-2'
          , data-type: 'add-to-cart-form'
          , is: 'product-form'
        -%}
          <div class="select{% if product.has_only_default_variant %} hidden{% endif %}">
            <select
              name="id"
              class="sticky-atc-bar__variant-select form-control form-control--select"
              aria-label="{{ 'accessibility.select_variant' | t }}">
              {%- for variant in product.variants -%}
                {%- liquid
                  assign selected = false
                  if variant.id == product.selected_or_first_available_variant.id
                    assign selected = true
                  endif
                -%}
                <option
                  value="{{ variant.id }}"
                  {% if selected %}
                  selected="true"
                  {% endif %}>
                  {{ variant.title }}
                </option>
              {%- endfor -%}
            </select>
            {%- render 'icon-caret-down'
              , size: '2xs' -%}
          </div>
          {%- if block.settings.show_quantity -%}
            <div id="QuantityForm-{{ section.id }}">
              {%- liquid
                assign qty_class = ''
                unless product.has_only_default_variant
                  assign qty_class = 'hidden md:flex'
                endunless

                assign cart_qty = cart | item_count_for_variant: product.selected_or_first_available_variant.id
              -%}
              <quantity-input
                class="quantity {{ qty_class }}"
                data-section-id="{{ section.id }}"
                data-product-id="{{ product.id }}">
                <button
                  class="quantity__button"
                  name="minus"
                  type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.decrease' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon-minus' %}
                </button>
                <input
                  class="quantity__input"
                  type="number"
                  name="quantity"
                  id="Quantity-{{ section.id }}"
                  data-cart-quantity="{{ cart_qty }}"
                  step="{{ product.selected_or_first_available_variant.quantity_rule.increment }}"
                  value="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  data-quantity-variant-id="{{ product.selected_or_first_available_variant.id }}"
                  data-min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  {% if product.selected_or_first_available_variant.quantity_rule.max != null %}
                  data-max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                  max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                  {% endif %}
                  inputmode="numeric"
                  autocomplete="off"
                  form="{{ product_form_id }}">
                <button
                  class="quantity__button"
                  name="plus"
                  type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.increase' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon-plus' %}
                </button>
              </quantity-input>
            </div>
          {% endif %}
          <div class="product-form__buttons flex items-center gap-2">
            {%- if block.settings.show_atc_button -%}
              <button
                type="submit"
                name="add"
                class="product-form__submit btn {% if show_dynamic_checkout_buttons and product.selling_plan_groups == empty %}btn--secondary{% else %}btn--primary{% endif %} w-full"
                {% if product.selected_or_first_available_variant.available == false %}
                disabled
                {% endif %}>
                <span class="btn__text">
                  {%- if product.selected_or_first_available_variant.available -%}
                    {{ 'products.product.add_to_cart' | t }}
                  {%- else -%}
                    {{ 'products.product.sold_out' | t }}
                  {%- endif -%}
                </span>
                {% render 'loading-spinner' %}
              </button>
            {% endif %}
            {%- if show_dynamic_checkout_buttons -%}
              <div class="product-form__button-dynamic hidden md:block">
                {{ form | payment_button }}
              </div>
            {%- endif -%}
          </div>
        {%- endform -%}
      </sticky-atc-bar>
      <script type="application/json">
        {{ product.variants | json }}
      </script>
    </div>
  {%- endif -%}
{%- endif -%}

<script>
  (function() {
    // Bundle product data from Liquid
    const isBundleProduct = {{ product.variants.first.metafields.custom.is_bundle | json }};
    const bundleProducts = {{ product.variants.first.metafields.custom.bundle_products.value | json }};
    const bundleQuantities = {{ product.variants.first.metafields.custom.bundle_quantities.value | json }};
    const bundleDiscount = {{ product.variants.first.metafields.custom.bundle_discount.value | json }};
    const variantId = {{ product.variants.first.id | json }};
    const sectionId = '{{ section.id }}';

    console.log('Sticky ATC Bundle product detection:', {
      isBundleProduct,
      bundleProducts,
      bundleQuantities,
      bundleDiscount,
      variantId
    });

    // Function to check bundle inventory availability
    function checkBundleInventory(userQuantity) {
      console.log("bundle products list data", bundleProducts);
      console.log("bundle_products_inventory_quantities", bundle_products_inventory_quantities);

      if (!bundleProducts || !bundleQuantities) return { valid: false, message: 'Bundle data not available' };

      for (let i = 0; i < bundleProducts.length; i++) {
        const variant = bundleProducts[i];
        const bundleQuantity = bundleQuantities[i] || 1;
        const requiredQuantity = bundleQuantity * userQuantity;

        const inventoryQuantity = bundle_products_inventory_quantities[i] || 0;

        console.log(`Checking ${variant.title}: Required ${requiredQuantity}, Available ${inventoryQuantity}`);

        if (requiredQuantity > inventoryQuantity) {
          return {
            valid: false,
            message: `Insufficient inventory for ${variant.title}. Required: ${requiredQuantity}, Available: ${inventoryQuantity}`
          };
        }
      }

      return { valid: true };
    }

    // Function to get maximum allowed quantity for bundle
    function getMaxBundleQuantity() {
      if (!bundleProducts || !bundleQuantities || bundleProducts.length === 0) return 0;

      let maxQuantity = Infinity;

      for (let i = 0; i < bundleProducts.length; i++) {
        const variant = bundleProducts[i];
        const bundleQuantity = bundleQuantities[i] || 1;
        const inventoryQuantity = bundle_products_inventory_quantities[i] || 0;
        const maxForThisProduct = Math.floor(inventoryQuantity / bundleQuantity);

        if (maxForThisProduct < maxQuantity) {
          maxQuantity = maxForThisProduct;
        }
      }

      return maxQuantity === Infinity ? 0 : maxQuantity;
    }

    // Custom Add to Cart Function for Bundle Products
    function handleBundleAddToCart(event) {
      event.preventDefault();
      event.stopPropagation();
      console.log('Bundle add to cart triggered');
      console.log('Event prevented and stopped propagation');

      if (!isBundleProduct || !bundleProducts || bundleProducts.length === 0) {
        console.log('Not a bundle product, proceeding with normal form submission');
        // Not a bundle product, proceed with normal form submission
        const form = event.target.closest('form');
        if (form) {
          form.submit();
        }
        return;
      }

      // Get user selected quantity
      const quantityInput = document.querySelector('#Quantity-' + sectionId) ||
                           document.querySelector('input[name="quantity"]') ||
                           { value: 1 };
      const userQuantity = parseInt(quantityInput.value) || 1;

      console.log('User quantity:', userQuantity);

      // Check inventory before proceeding
      const inventoryCheck = checkBundleInventory(userQuantity);
      if (!inventoryCheck.valid) {
        showMessage(inventoryCheck.message, 'error');
        return;
      }

      // Generate a unique bundle ID for this bundle purchase
      const bundleId = `bundle-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Prepare cart items with bundle metafields as properties
      const items = bundleProducts.map((variant, index) => {
        const bundleQuantity = bundleQuantities && bundleQuantities[index] ? bundleQuantities[index] : 1;
        const finalQuantity = bundleQuantity * userQuantity;

        console.log(`Variant ${index + 1}: ${variant.title || 'Unknown Variant'}`);
        console.log(`Bundle quantity: ${bundleQuantity}, User quantity: ${userQuantity}, Final quantity: ${finalQuantity}`);

        // Create properties object with all metafields
        const properties = {
          '_bundle_id': bundleId,
          '_is_bundle': true,
          '_variant_id': variantId,
          '_bundle_quantity': bundleQuantity,
          '_user_quantity': userQuantity,
          '_product_title': variant.title || 'Bundle Variant',
          '_product_id': variant.id,
        };

        // Add bundle discount if available
        if (bundleDiscount) {
          properties['_bundle_discount'] = bundleDiscount;
          properties['_discount_value'] = bundleDiscount;
        }

        // Add all bundle products data as a property
        properties['_bundle_products_data'] = JSON.stringify(bundleProducts);
        properties["_bundle_name"] = {{ product.title | json }};

        return {
          id: variant.id,
          quantity: finalQuantity,
          properties: properties
        };
      });

      console.log('Cart items to add:', items);

      // Add items to cart via AJAX
      addBundleToCart(items);
    }

    // Function to add bundle items to cart
    async function addBundleToCart(items) {
      try {
        // Show loading state
        const stickyAtcBar = document.querySelector('sticky-atc-bar-minimalist') || document.querySelector('.sticky-atc-bar');
        const submitButton = stickyAtcBar ? stickyAtcBar.querySelector('[name="add"]') : null;
        if (submitButton) {
          submitButton.disabled = true;
          submitButton.classList.add('btn--loading');
          const buttonText = submitButton.querySelector('span') || submitButton.querySelector('.btn__text');
          const originalText = buttonText ? buttonText.textContent : '';
          if (buttonText) {
            buttonText.textContent = 'Adding...';
          }
        }

        // Add items one by one to avoid inventory conflicts
        const results = [];
        let successCount = 0;
        let errorCount = 0;

        for (const item of items) {
          try {
            console.log('Adding individual item:', item);

            const response = await fetch('/cart/add.js', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                id: item.id,
                quantity: item.quantity,
                properties: item.properties
              })
            });

            if (response.ok) {
              const result = await response.json();
              console.log('Item added successfully:', result);
              results.push({ success: true, item: item, result: result });
              successCount++;
            } else {
              const errorData = await response.json();
              console.error('Error adding item:', errorData);
              results.push({ success: false, item: item, error: errorData });
              errorCount++;
            }
          } catch (itemError) {
            console.error('Error adding item:', itemError);
            results.push({ success: false, item: item, error: itemError });
            errorCount++;
          }
        }

        console.log('Bundle add results:', results);

        if (successCount > 0) {
          // Update cart state and show cart drawer like normal products
          await updateCartStateAndShowDrawerSimple();
          console.log('Bundle products added successfully - cart drawer opened');
        } else {
          showMessage('{{ "products.product.error_adding_to_cart" | t | default: "Error adding to cart" }}', 'error');
        }

      } catch (error) {
        console.error('Error adding bundle products to cart:', error);
        showMessage('{{ "products.product.error_adding_to_cart" | t | default: "Error adding to cart" }}', 'error');
      } finally {
        // Reset button state
        const stickyAtcBar = document.querySelector('sticky-atc-bar-minimalist') || document.querySelector('.sticky-atc-bar');
        const submitButton = stickyAtcBar ? stickyAtcBar.querySelector('[name="add"]') : null;
        if (submitButton) {
          submitButton.disabled = false;
          submitButton.classList.remove('btn--loading');
          const buttonText = submitButton.querySelector('span') || submitButton.querySelector('.btn__text');
          if (buttonText) {
            buttonText.textContent = '{{ "products.product.add_to_cart_short" | t }}';
          }
        }
      }
    }

    // Simple function to update cart state and show cart drawer
    async function updateCartStateAndShowDrawerSimple() {
      try {
        console.log('Updating cart state and showing cart drawer');

        // Get cart drawer section ID
        const cartDrawer = document.querySelector('cart-drawer');
        const cartDrawerSectionId = cartDrawer ? cartDrawer.getAttribute('data-section-id') : null;
        
        if (!cartDrawerSectionId) {
          console.error('Cart drawer section ID not found');
          return;
        }

        // Fetch both cart data and cart drawer section (like ProductForm does)
        const [cartResponse, sectionResponse] = await Promise.all([
          fetch('/cart.js'),
          fetch(`/?section_id=${cartDrawerSectionId}`)
        ]);
        
        const cartData = await cartResponse.json();
        const sectionHtml = await sectionResponse.text();
        
        // Parse the section HTML to get the cart drawer content
        const parser = new DOMParser();
        const parsedSection = parser.parseFromString(sectionHtml, 'text/html');
        const cartDrawerSection = parsedSection.querySelector(`#shopify-section-${cartDrawerSectionId}`);
        
        // Create the sections object that the theme expects
        const sections = {};
        if (cartDrawerSection) {
          sections[`sections--${cartDrawerSectionId}__cart-drawer`] = cartDrawerSection.outerHTML;
        }
        
        // Combine cart data with sections (like ProductForm does)
        const cartJson = {
          ...cartData,
          sections: sections
        };
        
        // Show cart drawer first, then update cart state
        if (cartDrawer && cartDrawer.show) {
          // Wait a bit for DOM to be ready, then show cart drawer
          setTimeout(() => {
            const stickyAtcBar = document.querySelector('sticky-atc-bar-minimalist') || document.querySelector('.sticky-atc-bar');
            const submitButton = stickyAtcBar ? stickyAtcBar.querySelector('[name="add"]') : null;
            if (submitButton) {
              cartDrawer.show(submitButton);
            } else {
              // Fallback: show cart drawer without specific focus element
              cartDrawer.show();
            }
            
            // Update cart drawer content directly first
            setTimeout(() => {
              // Update cart drawer content directly
              updateCartDrawerContent(cartJson, cartDrawerSectionId);
              
              // Then trigger cart update events (with delay to avoid focus issues)
              setTimeout(() => {
                // Update cart badge manually to avoid focus trap issues
                updateCartBadge(cartJson);
                
                // Dispatch product added event (same as ProductForm)
                document.dispatchEvent(new CustomEvent('product-ajax:added', {
                  detail: {
                    product: { status: 'success' },
                    cart: cartJson
                  }
                }));
                
                console.log('Cart drawer content and badge updated successfully');
              }, 300); // Longer delay to ensure content is updated
              
            }, 200); // Wait for cart drawer to be fully open
            
          }, 100);
        }
        
        console.log('Cart state updated and drawer shown successfully');
        
      } catch (error) {
        console.error('Error updating cart state:', error);
      }
    }

    // Function to update cart drawer content directly
    function updateCartDrawerContent(cartJson, cartDrawerSectionId) {
      try {
        console.log('Updating cart drawer content directly...');
        
        // Get the cart drawer body and footer elements
        const cartDrawerBody = document.querySelector(`#CartDrawerBody-${cartDrawerSectionId}`);
        const cartDrawerFooter = document.querySelector(`#CartDrawerFooter-${cartDrawerSectionId}`);
        const cartDrawerEmpty = document.querySelector(`#CartDrawerEmpty-${cartDrawerSectionId}`);
        
        // Update cart drawer body with new content
        if (cartDrawerBody && cartJson.sections) {
          const sectionKey = `sections--${cartDrawerSectionId}__cart-drawer`;
          const sectionContent = cartJson.sections[sectionKey];
          
          if (sectionContent) {
            // Parse the section content
            const parser = new DOMParser();
            const parsedSection = parser.parseFromString(sectionContent, 'text/html');
            
            // Update cart drawer body
            const newCartDrawerBody = parsedSection.querySelector(`#CartDrawerBody-${cartDrawerSectionId}`);
            if (newCartDrawerBody && cartDrawerBody) {
              cartDrawerBody.innerHTML = newCartDrawerBody.innerHTML;
              console.log('Cart drawer body updated');
            }
            
            // Update cart drawer footer
            const newCartDrawerFooter = parsedSection.querySelector(`#CartDrawerFooter-${cartDrawerSectionId}`);
            if (newCartDrawerFooter && cartDrawerFooter) {
              cartDrawerFooter.innerHTML = newCartDrawerFooter.innerHTML;
              console.log('Cart drawer footer updated');
            }
            
            // Update cart drawer empty state
            const newCartDrawerEmpty = parsedSection.querySelector(`#CartDrawerEmpty-${cartDrawerSectionId}`);
            if (newCartDrawerEmpty && cartDrawerEmpty) {
              cartDrawerEmpty.innerHTML = newCartDrawerEmpty.innerHTML;
              console.log('Cart drawer empty state updated');
            }
          }
        }
        
        // Show/hide cart drawer sections based on cart state
        if (cartJson.item_count > 0) {
          if (cartDrawerBody) cartDrawerBody.classList.remove('hidden');
          if (cartDrawerFooter) cartDrawerFooter.classList.remove('hidden');
          if (cartDrawerEmpty) cartDrawerEmpty.classList.add('hidden');
        } else {
          if (cartDrawerBody) cartDrawerBody.classList.add('hidden');
          if (cartDrawerFooter) cartDrawerFooter.classList.add('hidden');
          if (cartDrawerEmpty) cartDrawerEmpty.classList.remove('hidden');
        }
        
        console.log('Cart drawer content updated successfully');
        
      } catch (error) {
        console.error('Error updating cart drawer content:', error);
      }
    }

    // Function to update cart badge in header
    function updateCartBadge(cartData) {
      console.log('Updating cart badge with cart data:', cartData);

      const cartCountElements = document.querySelectorAll('cart-count');

      cartCountElements.forEach(element => {
        const itemCount = cartData.item_count || 0;
        let count = itemCount > 99 ? '99+' : itemCount.toString();

        if (element.dataset.type === 'blank') {
          count = `(${count})`;
        }

        if (element.classList.contains('cart-count--absolute')) {
          if (itemCount > 99) {
            element.innerHTML = `<span class="text-sm-extra">${count}</span>`;
            element.classList.add('cart-count--small-medium');
          } else {
            element.innerText = count;
            element.classList.remove('cart-count--small-medium');
          }
        } else {
          element.innerText = count;
        }

        element.hidden = itemCount === 0;

        const method = itemCount === 0 ? 'remove' : 'add';
        document.documentElement.classList[method]('cart-has-items');

        console.log('Updated cart count element:', element, 'with count:', itemCount);
      });

      // Also trigger the cart update event for other components
      // Note: We don't publish FoxTheme cart update here to avoid sections error
      // The cart drawer refresh already handles the proper FoxTheme events
      console.log('Cart badge updated - skipping FoxTheme cart update to avoid sections error');

      console.log('Cart badge update completed');
    }

    // Function to show messages
    function showMessage(message, type = 'info') {
      const errorWrapper = document.querySelector('.product-form__error-message-wrapper');
      const errorMessage = document.querySelector('.product-form__error-message');

      if (errorWrapper && errorMessage) {
        errorMessage.textContent = message;
        errorWrapper.hidden = false;

        if (type === 'success') {
          errorMessage.style.color = 'green';
        } else if (type === 'warning') {
          errorMessage.style.color = 'orange';
        } else if (type === 'error') {
          errorMessage.style.color = 'red';
        } else {
          errorMessage.style.color = '';
        }

        setTimeout(() => {
          errorWrapper.hidden = true;
        }, 5000);
      } else {
        alert(message);
      }
    }

    function initializeBundleProduct() {
      console.log('Initializing sticky ATC bundle product');
      
      // Target only the sticky ATC bar submit button, not the main product form button
      const stickyAtcBar = document.querySelector('sticky-atc-bar-minimalist') || document.querySelector('.sticky-atc-bar');
      const submitButton = stickyAtcBar ? stickyAtcBar.querySelector('[name="add"]') : null;
      
      if (submitButton && isBundleProduct) {
        console.log('Attaching bundle product event listener to sticky ATC button:', submitButton);
        console.log('Bundle product detected:', isBundleProduct);
        submitButton.addEventListener('click', handleBundleAddToCart);
      } else if (submitButton) {
        console.log('Sticky ATC button found but not a bundle product');
      } else {
        console.log('Sticky ATC submit button not found');
      }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeBundleProduct);
    } else {
      initializeBundleProduct();
    }

    // Also try after a delay to ensure all elements are rendered
    setTimeout(initializeBundleProduct, 100);
  })();
</script>
